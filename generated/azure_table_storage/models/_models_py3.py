# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6207, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import List, Union, Dict

from azure.core.exceptions import HttpResponseError
from msrest.serialization import Model


class AccessPolicy(Model):
    """An Access policy.

    All required parameters must be populated in order to send to Azure.

    :param start: Required. the date-time the policy is active.
    :type start: ~datetime.datetime
    :param expiry: Required. the date-time the policy expires.
    :type expiry: ~datetime.datetime
    :param permission: Required. the permissions for the acl policy.
    :type permission: str
    """

    _validation = {
        'start': {'required': True},
        'expiry': {'required': True},
        'permission': {'required': True},
    }

    _attribute_map = {
        'start': {'key': 'Start', 'type': 'iso-8601'},
        'expiry': {'key': 'Expiry', 'type': 'iso-8601'},
        'permission': {'key': 'Permission', 'type': 'str'},
    }

    def __init__(self, *, start: datetime.datetime, expiry: datetime.datetime, permission: str, **kwargs) -> None:
        super(AccessPolicy, self).__init__(**kwargs)
        self.start = start
        self.expiry = expiry
        self.permission = permission


class CorsRule(Model):
    """CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain. Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain.

    All required parameters must be populated in order to send to Azure.

    :param allowed_origins: Required. The origin domains that are permitted to make
     a request against the storage service via CORS. The origin domain is the domain
     from which the request originates. Note that the origin must be an exact case-
     sensitive match with the origin that the user age sends to the service. You can
     also use the wildcard character '*' to allow all origin domains to make requests
     via CORS.
    :type allowed_origins: str
    :param allowed_methods: Required. The methods (HTTP request verbs) that the
     origin domain may use for a CORS request. (comma separated).
    :type allowed_methods: str
    :param allowed_headers: Required. the request headers that the origin domain may
     specify on the CORS request.
    :type allowed_headers: str
    :param exposed_headers: Required. The response headers that may be sent in the
     response to the CORS request and exposed by the browser to the request issuer.
    :type exposed_headers: str
    :param max_age_in_seconds: Required. The maximum amount time that a browser
     should cache the preflight OPTIONS request.
    :type max_age_in_seconds: int
    """

    _validation = {
        'allowed_origins': {'required': True},
        'allowed_methods': {'required': True},
        'allowed_headers': {'required': True},
        'exposed_headers': {'required': True},
        'max_age_in_seconds': {'required': True, 'minimum': 0},
    }

    _attribute_map = {
        'allowed_origins': {'key': 'AllowedOrigins', 'type': 'str'},
        'allowed_methods': {'key': 'AllowedMethods', 'type': 'str'},
        'allowed_headers': {'key': 'AllowedHeaders', 'type': 'str'},
        'exposed_headers': {'key': 'ExposedHeaders', 'type': 'str'},
        'max_age_in_seconds': {'key': 'MaxAgeInSeconds', 'type': 'int'},
    }

    def __init__(self, *, allowed_origins: str, allowed_methods: str, allowed_headers: str, exposed_headers: str, max_age_in_seconds: int, **kwargs) -> None:
        super(CorsRule, self).__init__(**kwargs)
        self.allowed_origins = allowed_origins
        self.allowed_methods = allowed_methods
        self.allowed_headers = allowed_headers
        self.exposed_headers = exposed_headers
        self.max_age_in_seconds = max_age_in_seconds


class GeoReplication(Model):
    """GeoReplication.

    All required parameters must be populated in order to send to Azure.

    :param status: Required. The status of the secondary location. Possible values
     include: 'live', 'bootstrap', 'unavailable'.
    :type status: str or ~azure_table_storage.models.GeoReplicationStatusType
    :param last_sync_time: Required. A GMT date/time value, to the second. All
     primary writes preceding this value are guaranteed to be available for read
     operations at the secondary. Primary writes after this point in time may or may
     not be available for reads.
    :type last_sync_time: ~datetime.datetime
    """

    _validation = {
        'status': {'required': True},
        'last_sync_time': {'required': True},
    }

    _attribute_map = {
        'status': {'key': 'Status', 'type': 'str'},
        'last_sync_time': {'key': 'LastSyncTime', 'type': 'rfc-1123'},
    }

    def __init__(self, *, status: Union[str, "GeoReplicationStatusType"], last_sync_time: datetime.datetime, **kwargs) -> None:
        super(GeoReplication, self).__init__(**kwargs)
        self.status = status
        self.last_sync_time = last_sync_time


class Logging(Model):
    """Azure Analytics Logging settings.

    All required parameters must be populated in order to send to Azure.

    :param version: Required. The version of Storage Analytics to configure.
    :type version: str
    :param delete: Required. Indicates whether all delete requests should be logged.
    :type delete: bool
    :param read: Required. Indicates whether all read requests should be logged.
    :type read: bool
    :param write: Required. Indicates whether all write requests should be logged.
    :type write: bool
    :param retention_policy: Required. the retention policy.
    :type retention_policy: ~azure_table_storage.models.RetentionPolicy
    """

    _validation = {
        'version': {'required': True},
        'delete': {'required': True},
        'read': {'required': True},
        'write': {'required': True},
        'retention_policy': {'required': True},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
        'delete': {'key': 'Delete', 'type': 'bool'},
        'read': {'key': 'Read', 'type': 'bool'},
        'write': {'key': 'Write', 'type': 'bool'},
        'retention_policy': {'key': 'RetentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(self, *, version: str, delete: bool, read: bool, write: bool, retention_policy: "RetentionPolicy", **kwargs) -> None:
        super(Logging, self).__init__(**kwargs)
        self.version = version
        self.delete = delete
        self.read = read
        self.write = write
        self.retention_policy = retention_policy


class Metrics(Model):
    """Metrics.

    All required parameters must be populated in order to send to Azure.

    :param version: The version of Storage Analytics to configure.
    :type version: str
    :param enabled: Required. Indicates whether metrics are enabled for the Queue
     service.
    :type enabled: bool
    :param include_apis: Indicates whether metrics should generate summary
     statistics for called API operations.
    :type include_apis: bool
    :param retention_policy: the retention policy.
    :type retention_policy: ~azure_table_storage.models.RetentionPolicy
    """

    _validation = {
        'enabled': {'required': True},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
        'enabled': {'key': 'Enabled', 'type': 'bool'},
        'include_apis': {'key': 'IncludeAPIs', 'type': 'bool'},
        'retention_policy': {'key': 'RetentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(self, *, enabled: bool, version: str=None, include_apis: bool=None, retention_policy: "RetentionPolicy"=None, **kwargs) -> None:
        super(Metrics, self).__init__(**kwargs)
        self.version = version
        self.enabled = enabled
        self.include_apis = include_apis
        self.retention_policy = retention_policy


class RetentionPolicy(Model):
    """the retention policy.

    All required parameters must be populated in order to send to Azure.

    :param enabled: Required. Indicates whether a retention policy is enabled for
     the storage service.
    :type enabled: bool
    :param days: Indicates the number of days that metrics or logging or soft-
     deleted data should be retained. All data older than this value will be deleted.
    :type days: int
    """

    _validation = {
        'enabled': {'required': True},
        'days': {'minimum': 1},
    }

    _attribute_map = {
        'enabled': {'key': 'Enabled', 'type': 'bool'},
        'days': {'key': 'Days', 'type': 'int'},
    }

    def __init__(self, *, enabled: bool, days: int=None, **kwargs) -> None:
        super(RetentionPolicy, self).__init__(**kwargs)
        self.enabled = enabled
        self.days = days


class SignedIdentifier(Model):
    """signed identifier.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. a unique id.
    :type id: str
    :param access_policy: Required. An Access policy.
    :type access_policy: ~azure_table_storage.models.AccessPolicy
    """

    _validation = {
        'id': {'required': True},
        'access_policy': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'access_policy': {'key': 'AccessPolicy', 'type': 'AccessPolicy'},
    }

    def __init__(self, *, id: str, access_policy: "AccessPolicy", **kwargs) -> None:
        super(SignedIdentifier, self).__init__(**kwargs)
        self.id = id
        self.access_policy = access_policy


class StorageErrorException(HttpResponseError):
    """Server responded with exception of type: 'StorageError'.

    :param response: Server response to be deserialized.
    :param error_model: A deserialized model of the response body as model.
    """

    def __init__(self, response, error_model):
        self.error = error_model
        super(StorageErrorException, self).__init__(response=response, error_model=error_model)

    @classmethod
    def from_response(cls, response, deserialize):
        """Deserialize this response as this exception, or a subclass of this exception.

        :param response: Server response to be deserialized.
        :param deserialize: A deserializer
        """
        model_name = 'StorageError'
        error = deserialize(model_name, response)
        if error is None:
            error = deserialize.dependencies[model_name]()
        return error._EXCEPTION_TYPE(response, error)


class StorageError(Model):
    """StorageError.

    :param message:
    :type message: str
    """
    _EXCEPTION_TYPE = StorageErrorException

    _attribute_map = {
        'message': {'key': 'Message', 'type': 'str'},
    }

    def __init__(self, *, message: str=None, **kwargs) -> None:
        super(StorageError, self).__init__(**kwargs)
        self.message = message


class StorageServiceProperties(Model):
    """Storage Service Properties.

    :param logging: Azure Analytics Logging settings.
    :type logging: ~azure_table_storage.models.Logging
    :param hour_metrics:
    :type hour_metrics: ~azure_table_storage.models.Metrics
    :param minute_metrics:
    :type minute_metrics: ~azure_table_storage.models.Metrics
    :param cors: The set of CORS rules.
    :type cors: list[~azure_table_storage.models.CorsRule]
    """

    _attribute_map = {
        'logging': {'key': 'Logging', 'type': 'Logging'},
        'hour_metrics': {'key': 'HourMetrics', 'type': 'Metrics'},
        'minute_metrics': {'key': 'MinuteMetrics', 'type': 'Metrics'},
        'cors': {'key': 'Cors', 'type': '[CorsRule]'},
    }

    def __init__(self, *, logging: "Logging"=None, hour_metrics: "Metrics"=None, minute_metrics: "Metrics"=None, cors: List["CorsRule"]=None, **kwargs) -> None:
        super(StorageServiceProperties, self).__init__(**kwargs)
        self.logging = logging
        self.hour_metrics = hour_metrics
        self.minute_metrics = minute_metrics
        self.cors = cors


class StorageServiceStats(Model):
    """Stats for the storage service.

    :param geo_replication:
    :type geo_replication: ~azure_table_storage.models.GeoReplication
    """

    _attribute_map = {
        'geo_replication': {'key': 'GeoReplication', 'type': 'GeoReplication'},
    }

    def __init__(self, *, geo_replication: "GeoReplication"=None, **kwargs) -> None:
        super(StorageServiceStats, self).__init__(**kwargs)
        self.geo_replication = geo_replication


class TableEntityQueryResponse(Model):
    """The properties for the table entity query response.

    :param odata_metadata: The metadata response of the table.
    :type odata_metadata: str
    :param value: List of table entities.
    :type value: list[dict[str, object]]
    """

    _attribute_map = {
        'odata_metadata': {'key': 'odata\\.metadata', 'type': 'str'},
        'value': {'key': 'value', 'type': '[{object}]'},
    }

    def __init__(self, *, odata_metadata: str=None, value: List[Dict[str, object]]=None, **kwargs) -> None:
        super(TableEntityQueryResponse, self).__init__(**kwargs)
        self.odata_metadata = odata_metadata
        self.value = value


class TableProperties(Model):
    """The properties for creating a table.

    :param table_name: The name of the table to create.
    :type table_name: str
    """

    _attribute_map = {
        'table_name': {'key': 'TableName', 'type': 'str'},
    }

    def __init__(self, *, table_name: str=None, **kwargs) -> None:
        super(TableProperties, self).__init__(**kwargs)
        self.table_name = table_name


class TableQueryResponse(Model):
    """The properties for the table query response.

    :param odata_metadata: The metadata response of the table.
    :type odata_metadata: str
    :param value: List of tables.
    :type value: list[~azure_table_storage.models.TableResponseProperties]
    """

    _attribute_map = {
        'odata_metadata': {'key': 'odata\\.metadata', 'type': 'str'},
        'value': {'key': 'value', 'type': '[TableResponseProperties]'},
    }

    def __init__(self, *, odata_metadata: str=None, value: List["TableResponseProperties"]=None, **kwargs) -> None:
        super(TableQueryResponse, self).__init__(**kwargs)
        self.odata_metadata = odata_metadata
        self.value = value


class TableResponseProperties(Model):
    """The properties for the table response.

    :param table_name: The name of the table.
    :type table_name: str
    :param odata_type: The odata type of the table.
    :type odata_type: str
    :param odata_id: The id of the table.
    :type odata_id: str
    :param odata_edit_link: The edit link of the table.
    :type odata_edit_link: str
    """

    _attribute_map = {
        'table_name': {'key': 'TableName', 'type': 'str'},
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'odata_id': {'key': 'odata\\.id', 'type': 'str'},
        'odata_edit_link': {'key': 'odata\\.editLink', 'type': 'str'},
    }

    def __init__(self, *, table_name: str=None, odata_type: str=None, odata_id: str=None, odata_edit_link: str=None, **kwargs) -> None:
        super(TableResponseProperties, self).__init__(**kwargs)
        self.table_name = table_name
        self.odata_type = odata_type
        self.odata_id = odata_id
        self.odata_edit_link = odata_edit_link


class TableResponse(TableResponseProperties):
    """The response for a single table.

    :param table_name: The name of the table.
    :type table_name: str
    :param odata_type: The odata type of the table.
    :type odata_type: str
    :param odata_id: The id of the table.
    :type odata_id: str
    :param odata_edit_link: The edit link of the table.
    :type odata_edit_link: str
    :param odata_metadata: The metadata response of the table.
    :type odata_metadata: str
    """

    _attribute_map = {
        'table_name': {'key': 'TableName', 'type': 'str'},
        'odata_type': {'key': 'odata\\.type', 'type': 'str'},
        'odata_id': {'key': 'odata\\.id', 'type': 'str'},
        'odata_edit_link': {'key': 'odata\\.editLink', 'type': 'str'},
        'odata_metadata': {'key': 'odata\\.metadata', 'type': 'str'},
    }

    def __init__(self, *, table_name: str=None, odata_type: str=None, odata_id: str=None, odata_edit_link: str=None, odata_metadata: str=None, **kwargs) -> None:
        super(TableResponse, self).__init__(table_name=table_name, odata_type=odata_type, odata_id=odata_id, odata_edit_link=odata_edit_link, **kwargs)
        self.odata_metadata = odata_metadata
